<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.19"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>idaTSNSimulator: ArbiterIEEE802_1Qbv Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">idaTSNSimulator
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classArbiterIEEE802__1Qbv.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classArbiterIEEE802__1Qbv-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ArbiterIEEE802_1Qbv Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ArbiterIEEE802__1Qbv_8h_source.html">ArbiterIEEE802_1Qbv.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ArbiterIEEE802_1Qbv:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classArbiterIEEE802__1Qbv.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad6b9e550766dac70ef6a1f8b36eae5ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#ad6b9e550766dac70ef6a1f8b36eae5ef">ArbiterIEEE802_1Qbv</a> ()</td></tr>
<tr class="separator:ad6b9e550766dac70ef6a1f8b36eae5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea1448e189170b3c61e51a10205aab0"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#afea1448e189170b3c61e51a10205aab0">~ArbiterIEEE802_1Qbv</a> ()</td></tr>
<tr class="separator:afea1448e189170b3c61e51a10205aab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74028059ef520ea9b5213925530cfed2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a74028059ef520ea9b5213925530cfed2">initialize</a> (void) override</td></tr>
<tr class="separator:a74028059ef520ea9b5213925530cfed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af843e309dee7139c6b9a03426ab5e713"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#af843e309dee7139c6b9a03426ab5e713">handleMessage</a> (cMessage *message) override</td></tr>
<tr class="separator:af843e309dee7139c6b9a03426ab5e713"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a483b253b7682124d45b240dfc4f3dbf8"><td class="memItemLeft" align="right" valign="top">simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a483b253b7682124d45b240dfc4f3dbf8">getPeriodDuration</a> ()</td></tr>
<tr class="separator:a483b253b7682124d45b240dfc4f3dbf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032a4772c1f84a10ea12030977049216"><td class="memItemLeft" align="right" valign="top">simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a032a4772c1f84a10ea12030977049216">getCriticalIntervalDuration</a> ()</td></tr>
<tr class="separator:a032a4772c1f84a10ea12030977049216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fd7c49ad498d76c310d6c11a3106b4"><td class="memItemLeft" align="right" valign="top">simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#ad2fd7c49ad498d76c310d6c11a3106b4">convertDoubleIntoTime</a> (double valueToBeConverted)</td></tr>
<tr class="separator:ad2fd7c49ad498d76c310d6c11a3106b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c9b7ea0aa202bf0a4badcc7f643cb8"><td class="memItemLeft" align="right" valign="top">simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a62c9b7ea0aa202bf0a4badcc7f643cb8">calculateGuardBandDurationFromPayloadSize</a> (int payload)</td></tr>
<tr class="separator:a62c9b7ea0aa202bf0a4badcc7f643cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3181e0cf2fa66ae325d878910771e0d1"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a3181e0cf2fa66ae325d878910771e0d1">getPortSpeed</a> ()</td></tr>
<tr class="separator:a3181e0cf2fa66ae325d878910771e0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb75f9e4fdaee5c515b1f4ea7ab78d27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#abb75f9e4fdaee5c515b1f4ea7ab78d27">setEthPacketSizeFromPayload</a> (int payload)</td></tr>
<tr class="separator:abb75f9e4fdaee5c515b1f4ea7ab78d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552fb1c62e60dbc9b3027fa86d1aaa9d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a552fb1c62e60dbc9b3027fa86d1aaa9d">getCriticalClasses</a> ()</td></tr>
<tr class="separator:a552fb1c62e60dbc9b3027fa86d1aaa9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4c0504b4d2f0154197aea47ba789fc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#afc4c0504b4d2f0154197aea47ba789fc">setUpVectorCriticalPriorities</a> (std::vector&lt; int &gt; criticalPriorities)</td></tr>
<tr class="separator:afc4c0504b4d2f0154197aea47ba789fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab97fa6f701ff5e11559c572c7f47f5"><td class="memItemLeft" align="right" valign="top">simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a2ab97fa6f701ff5e11559c572c7f47f5">getTimeOffset</a> ()</td></tr>
<tr class="separator:a2ab97fa6f701ff5e11559c572c7f47f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5948b90c267839d8a73dc14db8488b7f"><td class="memItemLeft" align="right" valign="top">simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a5948b90c267839d8a73dc14db8488b7f">calculateTimeModulo</a> (simtime_t numeratorTime, simtime_t denominatorTime)</td></tr>
<tr class="separator:a5948b90c267839d8a73dc14db8488b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10fc98380803251a2e84b6a41b50cdf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#af10fc98380803251a2e84b6a41b50cdf">getInitialStateAndCalculateTriggerTimer</a> (simtime_t offset)</td></tr>
<tr class="separator:af10fc98380803251a2e84b6a41b50cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f2c6845bb60bcf077e55088533dbec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a70f2c6845bb60bcf077e55088533dbec">getNextState</a> (int <a class="el" href="classArbiterIEEE802__1Qbv.html#acc0d021f02fa25a45a27e84b970f338d">currentState</a>)</td></tr>
<tr class="separator:a70f2c6845bb60bcf077e55088533dbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0005b756e4fcacaf2c61cd432156429b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a0005b756e4fcacaf2c61cd432156429b">initializeTimerMessage</a> ()</td></tr>
<tr class="separator:a0005b756e4fcacaf2c61cd432156429b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39184bda71a0956c6a2c980feff27a89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a39184bda71a0956c6a2c980feff27a89">printInitializationConfiguration</a> ()</td></tr>
<tr class="separator:a39184bda71a0956c6a2c980feff27a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d69a39c0084340fb1bb9476c25b588"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a28d69a39c0084340fb1bb9476c25b588">dealWithInternalMessage</a> (cMessage *message)</td></tr>
<tr class="separator:a28d69a39c0084340fb1bb9476c25b588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12d94a88017d87d886e768697e979fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#aa12d94a88017d87d886e768697e979fd">dealWithSegmentTimerMessage</a> ()</td></tr>
<tr class="separator:aa12d94a88017d87d886e768697e979fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c1b70587cd0e7478d5b2270e58c054"><td class="memItemLeft" align="right" valign="top">simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a30c1b70587cd0e7478d5b2270e58c054">getSegmentDurationFromCurrentState</a> (int state)</td></tr>
<tr class="separator:a30c1b70587cd0e7478d5b2270e58c054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ff1bad6b476c2246491a637955d9e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a93ff1bad6b476c2246491a637955d9e1">dealWithTriggerSelf</a> ()</td></tr>
<tr class="separator:a93ff1bad6b476c2246491a637955d9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eaa901b870f020a51da4db8a34d42a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a3eaa901b870f020a51da4db8a34d42a4">sendFrameOut</a> ()</td></tr>
<tr class="separator:a3eaa901b870f020a51da4db8a34d42a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441e43984db6ac585a6673802d078877"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a441e43984db6ac585a6673802d078877">sendBufferRequest</a> ()</td></tr>
<tr class="separator:a441e43984db6ac585a6673802d078877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8434af0d0823404cdbfae6191b6d57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a5f8434af0d0823404cdbfae6191b6d57">dealWithExternalMessage</a> (cMessage *message)</td></tr>
<tr class="separator:a5f8434af0d0823404cdbfae6191b6d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32a52a76e43fd999138533f2e6d1d04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#aa32a52a76e43fd999138533f2e6d1d04">dealWithControlMessage</a> (cMessage *controlMessage)</td></tr>
<tr class="separator:aa32a52a76e43fd999138533f2e6d1d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d2b781c1db999c9434d41de54a4523"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#ae6d2b781c1db999c9434d41de54a4523">controlArbitrationBufferStatusList</a> (std::vector&lt; <a class="el" href="structethernetHeaderInformation.html">ethernetHeaderInformation</a> * &gt; bufferStatusList)</td></tr>
<tr class="separator:ae6d2b781c1db999c9434d41de54a4523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc97d96003ce0ff038736d0cd5dbbff8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structethernetHeaderInformation.html">ethernetHeaderInformation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#abc97d96003ce0ff038736d0cd5dbbff8">prepareBufferStatusList</a> (std::vector&lt; <a class="el" href="structethernetHeaderInformation.html">ethernetHeaderInformation</a> * &gt; bufferStatusList)</td></tr>
<tr class="separator:abc97d96003ce0ff038736d0cd5dbbff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1917afd66acbd6a70cb4798490640f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#ae1917afd66acbd6a70cb4798490640f0">arbitrateBufferStatusList</a> (std::vector&lt; <a class="el" href="structethernetHeaderInformation.html">ethernetHeaderInformation</a> * &gt; bufferStatusList)</td></tr>
<tr class="separator:ae1917afd66acbd6a70cb4798490640f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf556524f33a915f36dce5cd51fdab0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a2cf556524f33a915f36dce5cd51fdab0">sendBufferAuthorizedBuffer</a> (int authorizedBuffer)</td></tr>
<tr class="separator:a2cf556524f33a915f36dce5cd51fdab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615a48f9708d899bd47df9d021d0d9f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a615a48f9708d899bd47df9d021d0d9f5">dealWithEthernetFrame</a> (cMessage *frame)</td></tr>
<tr class="separator:a615a48f9708d899bd47df9d021d0d9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd2718ca667d2e22ec540c108a79811"><td class="memItemLeft" align="right" valign="top">simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#acbd2718ca667d2e22ec540c108a79811">calculateTransmissionDelay</a> (EthernetFrame *ethernetFrame)</td></tr>
<tr class="separator:acbd2718ca667d2e22ec540c108a79811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868a2fc6b4d6bec78f72cd7c8ad7104e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a868a2fc6b4d6bec78f72cd7c8ad7104e">setTriggerDelayEnd</a> (simtime_t transmissionPathDelay)</td></tr>
<tr class="separator:a868a2fc6b4d6bec78f72cd7c8ad7104e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:acc0d021f02fa25a45a27e84b970f338d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#acc0d021f02fa25a45a27e84b970f338d">currentState</a></td></tr>
<tr class="memdesc:acc0d021f02fa25a45a27e84b970f338d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the state is equal the current time segment  <a href="classArbiterIEEE802__1Qbv.html#acc0d021f02fa25a45a27e84b970f338d">More...</a><br /></td></tr>
<tr class="separator:acc0d021f02fa25a45a27e84b970f338d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8156b00418775f16c22bac5018e2a0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#af8156b00418775f16c22bac5018e2a0c">nextState</a></td></tr>
<tr class="memdesc:af8156b00418775f16c22bac5018e2a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">the next state is equal to the next time segment after the current  <a href="classArbiterIEEE802__1Qbv.html#af8156b00418775f16c22bac5018e2a0c">More...</a><br /></td></tr>
<tr class="separator:af8156b00418775f16c22bac5018e2a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51910380e66888746f37c9e603fbab26"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a51910380e66888746f37c9e603fbab26">maximumCriticalPayloadSize</a></td></tr>
<tr class="memdesc:a51910380e66888746f37c9e603fbab26"><td class="mdescLeft">&#160;</td><td class="mdescRight">set by user -&gt; defines the maximum payload number in bytes for critical priorities frames  <a href="classArbiterIEEE802__1Qbv.html#a51910380e66888746f37c9e603fbab26">More...</a><br /></td></tr>
<tr class="separator:a51910380e66888746f37c9e603fbab26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fd755ede90a7bfefba9ac1bcc1c8a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#ab6fd755ede90a7bfefba9ac1bcc1c8a6">maximumNoncriticalPayloadSize</a></td></tr>
<tr class="memdesc:ab6fd755ede90a7bfefba9ac1bcc1c8a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">set by user -&gt; defines the maximum payload number in bytes for noncritical priorities frames  <a href="classArbiterIEEE802__1Qbv.html#ab6fd755ede90a7bfefba9ac1bcc1c8a6">More...</a><br /></td></tr>
<tr class="separator:ab6fd755ede90a7bfefba9ac1bcc1c8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7f41b6ebe5d00859c1c6b467239466"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a9b7f41b6ebe5d00859c1c6b467239466">numberSupportedPriorities</a></td></tr>
<tr class="memdesc:a9b7f41b6ebe5d00859c1c6b467239466"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of supported priorities (= default 8 priorities)  <a href="classArbiterIEEE802__1Qbv.html#a9b7f41b6ebe5d00859c1c6b467239466">More...</a><br /></td></tr>
<tr class="separator:a9b7f41b6ebe5d00859c1c6b467239466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05927b157ee3b7b97f9d6f51105f999c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a05927b157ee3b7b97f9d6f51105f999c">switchMAC</a></td></tr>
<tr class="memdesc:a05927b157ee3b7b97f9d6f51105f999c"><td class="mdescLeft">&#160;</td><td class="mdescRight">MAC address of the switch.  <a href="classArbiterIEEE802__1Qbv.html#a05927b157ee3b7b97f9d6f51105f999c">More...</a><br /></td></tr>
<tr class="separator:a05927b157ee3b7b97f9d6f51105f999c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6f1e5e9a74ec81759e0a7cedcaf0e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#afb6f1e5e9a74ec81759e0a7cedcaf0e2">portIndex</a></td></tr>
<tr class="memdesc:afb6f1e5e9a74ec81759e0a7cedcaf0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">index of the <a class="el" href="classEgressPort.html">EgressPort</a> via which the frame is forwarded  <a href="classArbiterIEEE802__1Qbv.html#afb6f1e5e9a74ec81759e0a7cedcaf0e2">More...</a><br /></td></tr>
<tr class="separator:afb6f1e5e9a74ec81759e0a7cedcaf0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea78a285b6df89b8f6b794cf360fec7"><td class="memItemLeft" align="right" valign="top">simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#afea78a285b6df89b8f6b794cf360fec7">periodDuration</a></td></tr>
<tr class="memdesc:afea78a285b6df89b8f6b794cf360fec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">set by user -&gt; defines the duration of the period (= default 5 ms)  <a href="classArbiterIEEE802__1Qbv.html#afea78a285b6df89b8f6b794cf360fec7">More...</a><br /></td></tr>
<tr class="separator:afea78a285b6df89b8f6b794cf360fec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0409eae3ddaf78cdc00f5b07e179e6a"><td class="memItemLeft" align="right" valign="top">simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#af0409eae3ddaf78cdc00f5b07e179e6a">criticalIntervalDuration</a></td></tr>
<tr class="memdesc:af0409eae3ddaf78cdc00f5b07e179e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">set by user -&gt; defines the duration of the critical interval  <a href="classArbiterIEEE802__1Qbv.html#af0409eae3ddaf78cdc00f5b07e179e6a">More...</a><br /></td></tr>
<tr class="separator:af0409eae3ddaf78cdc00f5b07e179e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f55123dc25f8a1523ce8828dbf1f0d"><td class="memItemLeft" align="right" valign="top">simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#ab4f55123dc25f8a1523ce8828dbf1f0d">criticalSendingSegmentDuration</a></td></tr>
<tr class="memdesc:ab4f55123dc25f8a1523ce8828dbf1f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">critical interval is split into sending and guard band segment  <a href="classArbiterIEEE802__1Qbv.html#ab4f55123dc25f8a1523ce8828dbf1f0d">More...</a><br /></td></tr>
<tr class="separator:ab4f55123dc25f8a1523ce8828dbf1f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6b60356a8d1b81127061b1374ef7b4"><td class="memItemLeft" align="right" valign="top">simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a2c6b60356a8d1b81127061b1374ef7b4">criticalGuardBandSegmentDuration</a></td></tr>
<tr class="memdesc:a2c6b60356a8d1b81127061b1374ef7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">guard band segment is as long as a critical frame needs for transmission  <a href="classArbiterIEEE802__1Qbv.html#a2c6b60356a8d1b81127061b1374ef7b4">More...</a><br /></td></tr>
<tr class="separator:a2c6b60356a8d1b81127061b1374ef7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4b135244637d16f0a3b03faf77b71d"><td class="memItemLeft" align="right" valign="top">simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a9a4b135244637d16f0a3b03faf77b71d">noncriticalIntervalDuration</a></td></tr>
<tr class="memdesc:a9a4b135244637d16f0a3b03faf77b71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">non critical interval duration is the time remaining from the subtraction of period and criticalInterval  <a href="classArbiterIEEE802__1Qbv.html#a9a4b135244637d16f0a3b03faf77b71d">More...</a><br /></td></tr>
<tr class="separator:a9a4b135244637d16f0a3b03faf77b71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e1bbc231d84226038d5260ebcfb3c1"><td class="memItemLeft" align="right" valign="top">simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a04e1bbc231d84226038d5260ebcfb3c1">noncriticalSendingSegmentDuration</a></td></tr>
<tr class="memdesc:a04e1bbc231d84226038d5260ebcfb3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">non critical interval duration is split into sending and guard band segment  <a href="classArbiterIEEE802__1Qbv.html#a04e1bbc231d84226038d5260ebcfb3c1">More...</a><br /></td></tr>
<tr class="separator:a04e1bbc231d84226038d5260ebcfb3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65fcab578e1f85ec17dc3978f15b2c9"><td class="memItemLeft" align="right" valign="top">simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#aa65fcab578e1f85ec17dc3978f15b2c9">noncriticalGuardBandSegmentDuration</a></td></tr>
<tr class="memdesc:aa65fcab578e1f85ec17dc3978f15b2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">non critical guard band segment is as long as a non critical frame needs for transmission  <a href="classArbiterIEEE802__1Qbv.html#aa65fcab578e1f85ec17dc3978f15b2c9">More...</a><br /></td></tr>
<tr class="separator:aa65fcab578e1f85ec17dc3978f15b2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e2509c155332233b82a049b67621cf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a91e2509c155332233b82a049b67621cf">criticalPriorityClasses</a></td></tr>
<tr class="memdesc:a91e2509c155332233b82a049b67621cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">integer vector which stores the critical priorities (= default ("7 6"))  <a href="classArbiterIEEE802__1Qbv.html#a91e2509c155332233b82a049b67621cf">More...</a><br /></td></tr>
<tr class="separator:a91e2509c155332233b82a049b67621cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338efe0ed92e04b82722e0690e08d87e"><td class="memItemLeft" align="right" valign="top">simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a338efe0ed92e04b82722e0690e08d87e">timeOffset</a></td></tr>
<tr class="memdesc:a338efe0ed92e04b82722e0690e08d87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">timer, which allows to start the simulation in any time segment (= default 0 -&gt; critical timing segment)  <a href="classArbiterIEEE802__1Qbv.html#a338efe0ed92e04b82722e0690e08d87e">More...</a><br /></td></tr>
<tr class="separator:a338efe0ed92e04b82722e0690e08d87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ff6850fef2aab47c986255148fc3bc"><td class="memItemLeft" align="right" valign="top">simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#ae8ff6850fef2aab47c986255148fc3bc">triggerTimer</a></td></tr>
<tr class="memdesc:ae8ff6850fef2aab47c986255148fc3bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">timer to trigger a a self message  <a href="classArbiterIEEE802__1Qbv.html#ae8ff6850fef2aab47c986255148fc3bc">More...</a><br /></td></tr>
<tr class="separator:ae8ff6850fef2aab47c986255148fc3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036474f9a541a4bacce1eea6029966c0"><td class="memItemLeft" align="right" valign="top">cMessage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a036474f9a541a4bacce1eea6029966c0">segmentTriggerTimerMessage</a></td></tr>
<tr class="memdesc:a036474f9a541a4bacce1eea6029966c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">cMessage timer for changing states (time segments)  <a href="classArbiterIEEE802__1Qbv.html#a036474f9a541a4bacce1eea6029966c0">More...</a><br /></td></tr>
<tr class="separator:a036474f9a541a4bacce1eea6029966c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8db4be8fded860e673036b509e46815"><td class="memItemLeft" align="right" valign="top">cMessage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#ac8db4be8fded860e673036b509e46815">triggerSelf</a> = new cMessage()</td></tr>
<tr class="memdesc:ac8db4be8fded860e673036b509e46815"><td class="mdescLeft">&#160;</td><td class="mdescRight">cMessage timer for trigger Ethernet frame transmission  <a href="classArbiterIEEE802__1Qbv.html#ac8db4be8fded860e673036b509e46815">More...</a><br /></td></tr>
<tr class="separator:ac8db4be8fded860e673036b509e46815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734da0537a1d8f311e88b33e7c8e3970"><td class="memItemLeft" align="right" valign="top">EthernetFrame *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a734da0537a1d8f311e88b33e7c8e3970">ethernetFrameWaitForTransmission</a></td></tr>
<tr class="memdesc:a734da0537a1d8f311e88b33e7c8e3970"><td class="mdescLeft">&#160;</td><td class="mdescRight">arbiter stores only one Ethernet frame which must wait for its transmission to simulate transmission rate  <a href="classArbiterIEEE802__1Qbv.html#a734da0537a1d8f311e88b33e7c8e3970">More...</a><br /></td></tr>
<tr class="separator:a734da0537a1d8f311e88b33e7c8e3970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05156ead49eba8e59dfb38f8b76d012b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structethernetHeaderInformation.html">ethernetHeaderInformation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a05156ead49eba8e59dfb38f8b76d012b">currentBufferStatusList</a></td></tr>
<tr class="separator:a05156ead49eba8e59dfb38f8b76d012b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93297232e214169cb007dd3a0196526"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#ae93297232e214169cb007dd3a0196526">isCritical</a></td></tr>
<tr class="memdesc:ae93297232e214169cb007dd3a0196526"><td class="mdescLeft">&#160;</td><td class="mdescRight">boolean vector indicating which of the priorities is critical (= true) or not (= false)  <a href="classArbiterIEEE802__1Qbv.html#ae93297232e214169cb007dd3a0196526">More...</a><br /></td></tr>
<tr class="separator:ae93297232e214169cb007dd3a0196526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0d89cde180ce81a038f07f96e537d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a1f0d89cde180ce81a038f07f96e537d3">arbiterIsBusy</a></td></tr>
<tr class="memdesc:a1f0d89cde180ce81a038f07f96e537d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">variable that indicates that the arbitration is already in progress  <a href="classArbiterIEEE802__1Qbv.html#a1f0d89cde180ce81a038f07f96e537d3">More...</a><br /></td></tr>
<tr class="separator:a1f0d89cde180ce81a038f07f96e537d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bf83ee5fd90d5a8c58a99d4d2fe8ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArbiterIEEE802__1Qbv.html#a27bf83ee5fd90d5a8c58a99d4d2fe8ed">frameStoredInBuffer</a></td></tr>
<tr class="separator:a27bf83ee5fd90d5a8c58a99d4d2fe8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classArbiterIEEE802__1Qbv.html">ArbiterIEEE802_1Qbv</a> is an Arbiter() which arbitrate the stored Ethernet frames in <a class="el" href="classBuffersModule.html">BuffersModule</a>. It is also known as Time Aware <a class="el" href="classShaper.html">Shaper</a> (TAS).</p>
<p>TAS is a circuit-switched arbitration. The period is divided into two intervals</p><ol type="1">
<li>critical interval</li>
<li>noncritical interval Each interval is also divided into the following segments: *.1 sending segment *.2 guard band segment Only Ethernet frames with critical priorities are sent in the critical interval of the sending segment. In IEEE802_1Qbv, traffic classes with priorities 6 and 7 are classified as critical (set as default). For simulation purpose it is also possible to set other classes as critical as well. The guard band segment is only as long for an Ethernet frame to complete its transmission. No Ethernet frames start their transmission in this segment. In noncritical sending segment only non critical priority classes are sent (default priority 5-0). </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad6b9e550766dac70ef6a1f8b36eae5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b9e550766dac70ef6a1f8b36eae5ef">&#9670;&nbsp;</a></span>ArbiterIEEE802_1Qbv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArbiterIEEE802_1Qbv::ArbiterIEEE802_1Qbv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Class constructor - nothing to do here </p>

</div>
</div>
<a id="afea1448e189170b3c61e51a10205aab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea1448e189170b3c61e51a10205aab0">&#9670;&nbsp;</a></span>~ArbiterIEEE802_1Qbv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ArbiterIEEE802_1Qbv::~ArbiterIEEE802_1Qbv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Class destructor</p>
<p>Cancel and delete the self messages triggerSelf and segmentTriggerTimerMessage. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae1917afd66acbd6a70cb4798490640f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1917afd66acbd6a70cb4798490640f0">&#9670;&nbsp;</a></span>arbitrateBufferStatusList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ArbiterIEEE802_1Qbv::arbitrateBufferStatusList </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structethernetHeaderInformation.html">ethernetHeaderInformation</a> * &gt;&#160;</td>
          <td class="paramname"><em>bufferStatusList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Arbitrate the <a class="el" href="structethernetHeaderInformation.html">ethernetHeaderInformation</a> vector.</p>
<p>After the preparation of the <a class="el" href="structethernetHeaderInformation.html">ethernetHeaderInformation</a> vector an Ethernet frame is selected for transmission. It is first checked at which state (time segment) the simulation is. Critical sending segment -&gt; only Ethernet frames with critical priorities are transmit. Critical guard band segment -&gt; no Ethernet frame are transmit. Noncritical sending segment -&gt; only noncritical Ethernet frames (best effort) are transmit. If several messages of different noncritical or critical priorities are in the FrameBuffers, the selection is made according to static priority non preemptive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferStautsList</td><td>a vector containing pointer <a class="el" href="structethernetHeaderInformation.html">ethernetHeaderInformation</a> with set boolean variable ready </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value of the priority which specifies the <a class="el" href="classFrameBuffer.html">FrameBuffer</a> from which the first Ethernet frame is forwarded </dd></dl>

</div>
</div>
<a id="a62c9b7ea0aa202bf0a4badcc7f643cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c9b7ea0aa202bf0a4badcc7f643cb8">&#9670;&nbsp;</a></span>calculateGuardBandDurationFromPayloadSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t ArbiterIEEE802_1Qbv::calculateGuardBandDurationFromPayloadSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>payload</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the duration of the guard band depending on the payload size of an Ethernet frame.</p>
<p>The period is divided into critical and noncritical interval. Each interval itself is also divided into sending and guard band segments. The duration of the guard band segment depends on the maximum payload size of the Ethernet frame. The guard band is so long that one Ethernet frame can complete its transmission. But: no frame starts transmission in the guard band!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>integer of the Ethernet frame payload size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the duration of the guard band </dd></dl>

</div>
</div>
<a id="a5948b90c267839d8a73dc14db8488b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5948b90c267839d8a73dc14db8488b7f">&#9670;&nbsp;</a></span>calculateTimeModulo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t ArbiterIEEE802_1Qbv::calculateTimeModulo </td>
          <td>(</td>
          <td class="paramtype">simtime_t&#160;</td>
          <td class="paramname"><em>numeratorTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&#160;</td>
          <td class="paramname"><em>denominatorTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the time remaining after dividing two times.</p>
<p>This is required for setting the initial time segment with which the arbitration. It is not possible to divide simtime_t values and get the remainder. Therefore the denominator is subtracted from numerator until denominator is larger than numerator. The rest is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numeratorTime</td><td>simtime_t which is to divided </td></tr>
    <tr><td class="paramname">denominatorTime</td><td>simtime_t to be divided with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rest of the division </dd></dl>

</div>
</div>
<a id="acbd2718ca667d2e22ec540c108a79811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd2718ca667d2e22ec540c108a79811">&#9670;&nbsp;</a></span>calculateTransmissionDelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t ArbiterIEEE802_1Qbv::calculateTransmissionDelay </td>
          <td>(</td>
          <td class="paramtype">EthernetFrame *&#160;</td>
          <td class="paramname"><em>ethernetFrame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the transmission time of the Ethernet frame.</p>
<p>To set up a timer message that simulates the transmission time of the Ethernet frame it must first be calculated. This requires the Ethernet frame payload length and the port speed. (Port speed is obtained from <a class="el" href="classArbiterIEEE802__1Qbv.html#a3181e0cf2fa66ae325d878910771e0d1">getPortSpeed()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ethernetFrame</td><td>pointer of an EthernetFrame message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transmission time of the Ethernet frame </dd></dl>

</div>
</div>
<a id="ae6d2b781c1db999c9434d41de54a4523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d2b781c1db999c9434d41de54a4523">&#9670;&nbsp;</a></span>controlArbitrationBufferStatusList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArbiterIEEE802_1Qbv::controlArbitrationBufferStatusList </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structethernetHeaderInformation.html">ethernetHeaderInformation</a> * &gt;&#160;</td>
          <td class="paramname"><em>bufferStatusList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Control the arbitration of the received <a class="el" href="structethernetHeaderInformation.html">ethernetHeaderInformation</a> vector from the BufferControlMessage.</p>
<p>With the received <a class="el" href="structethernetHeaderInformation.html">ethernetHeaderInformation</a> vector the arbitration phase starts. The <a class="el" href="structethernetHeaderInformation.html">ethernetHeaderInformation</a> vector contains for each <a class="el" href="classFrameBuffer.html">FrameBuffer</a> in <a class="el" href="classBuffersModule.html">BuffersModule</a> the payload of the first Ethernet frame in the <a class="el" href="classFrameBuffer.html">FrameBuffer</a> as well as the priority of the the corresponding buffer. The arbitration phase is divided in two parts: prepareBufferStatusList(...) and arbitrateBufferStatusList</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferStatusList</td><td>a vector containing pointer <a class="el" href="structethernetHeaderInformation.html">ethernetHeaderInformation</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2fd7c49ad498d76c310d6c11a3106b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fd7c49ad498d76c310d6c11a3106b4">&#9670;&nbsp;</a></span>convertDoubleIntoTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t ArbiterIEEE802_1Qbv::convertDoubleIntoTime </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>valueToBeConverted</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a double value into simtime_t</p>
<p>Time values are entered as double values. Double has to be converted into time values to work with simttime_t.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valueToBeConverted</td><td>a double value which has to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted simtime_t value </dd></dl>

</div>
</div>
<a id="aa32a52a76e43fd999138533f2e6d1d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32a52a76e43fd999138533f2e6d1d04">&#9670;&nbsp;</a></span>dealWithControlMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArbiterIEEE802_1Qbv::dealWithControlMessage </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>controlMessage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deal with the external message BufferControlMessage.</p>
<p>Arriving external message is a BufferControlMessage. BufferControlMessages are messages to control the <a class="el" href="classBuffersModule.html">BuffersModule()</a>. There are two different flags that the Arbiter() must handle. BUFFER_CONTROL_UPDATE is a update message. It always arrives if a Ethernet frame with new priority is stored into a <a class="el" href="classFrameBuffer.html">FrameBuffer()</a>. BUFFER_LEVEL_RESPONSE is the answer of the BUFFER_LEVEL_REQUEST. First the Arbiter sends a request to the <a class="el" href="classBuffersModule.html">BuffersModule()</a> to get the fill level of the FrameBuffers(). Than the <a class="el" href="classBuffersModule.html">BuffersModule</a> answers with the BUFFER_LEVEL_RESPONSE containing a <a class="el" href="structethernetHeaderInformation.html">ethernetHeaderInformation</a> vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controlMessage</td><td>cMessage pointer to a BufferControlMessage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a615a48f9708d899bd47df9d021d0d9f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615a48f9708d899bd47df9d021d0d9f5">&#9670;&nbsp;</a></span>dealWithEthernetFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArbiterIEEE802_1Qbv::dealWithEthernetFrame </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deal with external message Ethernet frame.</p>
<p>Arriving external message is an Ethernet frame. The frame is temporarily stored in variable ethernetFrameWaitForTransmission until the transmission time is over. For simulation the transmission time a timer message TriggerSelf is scheduled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>cMessage pointer of an Ethernet Frame </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f8434af0d0823404cdbfae6191b6d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8434af0d0823404cdbfae6191b6d57">&#9670;&nbsp;</a></span>dealWithExternalMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArbiterIEEE802_1Qbv::dealWithExternalMessage </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deal with external message (Ethernet frame and BufferControlMessage)</p>
<p>The arbiter has to deal with internal (self) messages and external (BufferControlMessage and Ethernet frame) messages. BufferControlMessages are messages to control the <a class="el" href="classBuffersModule.html">BuffersModule()</a>. The arriving Ethernet frame is the message that was selected by the arbitration and is now forwarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>cMessage pointer to arriving external message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28d69a39c0084340fb1bb9476c25b588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d69a39c0084340fb1bb9476c25b588">&#9670;&nbsp;</a></span>dealWithInternalMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArbiterIEEE802_1Qbv::dealWithInternalMessage </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deal with internal messages (self messages).</p>
<p>The arbiter has to deal with internal (self) messages and external (bufferControl and Ethernet frame) messages. The internal messages simulates timer functions. Two internal messages must be distinguished. The segmentTriggerTimerMessage triggers always a self message after changing the state. The triggerSelf self message simulates the transmission of an Ethernet frame. It is triggered when the transmission time has expired and the Ethernet frame is transmit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>pointer to a self message, segmentTriggerTimerMessage or triggerSelf </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa12d94a88017d87d886e768697e979fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12d94a88017d87d886e768697e979fd">&#9670;&nbsp;</a></span>dealWithSegmentTimerMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArbiterIEEE802_1Qbv::dealWithSegmentTimerMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deal with internal message segmentTriggerTimerMessage.</p>
<p>A segmentTriggerTimerMessage is arrived. It indicates the finishing of a time segment. The current state is updated as well as the next state. The segmentTriggerTimerMessage is updated and scheduled. </p>

</div>
</div>
<a id="a93ff1bad6b476c2246491a637955d9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ff1bad6b476c2246491a637955d9e1">&#9670;&nbsp;</a></span>dealWithTriggerSelf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArbiterIEEE802_1Qbv::dealWithTriggerSelf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deal with internal message triggerSelf.</p>
<p>A triggerSelf message is arrived. It simulates the transmission time of the Ethernet frame. Its arriving indicates that the transmission time of the stored Ethernet Frame is finished. </p>

</div>
</div>
<a id="a552fb1c62e60dbc9b3027fa86d1aaa9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a552fb1c62e60dbc9b3027fa86d1aaa9d">&#9670;&nbsp;</a></span>getCriticalClasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; ArbiterIEEE802_1Qbv::getCriticalClasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the critical priority classes.</p>
<p>To transmit Ethernet frames in critical sending segment critical class priorities has to be set. Per default 7 and 6 are critical priorities. They are set as string in .ini file. They are converted as integer and stored into a integer vector.</p>
<dl class="section return"><dt>Returns</dt><dd>an integer vector containing the critical priorities </dd></dl>

</div>
</div>
<a id="a032a4772c1f84a10ea12030977049216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032a4772c1f84a10ea12030977049216">&#9670;&nbsp;</a></span>getCriticalIntervalDuration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t ArbiterIEEE802_1Qbv::getCriticalIntervalDuration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the duration of the critical interval</p>
<p>The period is divided into critical and noncritical interval. The duration of the critical interval has to be set by the user. Per default it is set to 3 ms.</p>
<dl class="section return"><dt>Returns</dt><dd>the duration of the critical interval </dd></dl>

</div>
</div>
<a id="af10fc98380803251a2e84b6a41b50cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10fc98380803251a2e84b6a41b50cdf">&#9670;&nbsp;</a></span>getInitialStateAndCalculateTriggerTimer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ArbiterIEEE802_1Qbv::getInitialStateAndCalculateTriggerTimer </td>
          <td>(</td>
          <td class="paramtype">simtime_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the state (time segment) with which the arbitration starts.</p>
<p>Depending on the time offset the initial state is set. If no time offset state is set (=0) the initial state is always the critical sending segment.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value of the initial state. </dd></dl>

</div>
</div>
<a id="a70f2c6845bb60bcf077e55088533dbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f2c6845bb60bcf077e55088533dbec">&#9670;&nbsp;</a></span>getNextState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ArbiterIEEE802_1Qbv::getNextState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currentState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the next state of the current state.</p>
<p>There are four states. The state transitions are fixed. From Critical sending to critical guard band to noncritical sending to noncritical guard band back to critical sending. For a correct arbitration, the next state must be set from the current state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentState</td><td>integer value of the current state (time segment) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value of the next state (time segment) </dd></dl>

</div>
</div>
<a id="a483b253b7682124d45b240dfc4f3dbf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a483b253b7682124d45b240dfc4f3dbf8">&#9670;&nbsp;</a></span>getPeriodDuration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t ArbiterIEEE802_1Qbv::getPeriodDuration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the duration of the period</p>
<p>The period duration is set by the user in .ini file and defines the the time length of a single arbitration run. Per default it is set to 5 ms.</p>
<dl class="section return"><dt>Returns</dt><dd>the duration of the period </dd></dl>

</div>
</div>
<a id="a3181e0cf2fa66ae325d878910771e0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3181e0cf2fa66ae325d878910771e0d1">&#9670;&nbsp;</a></span>getPortSpeed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long ArbiterIEEE802_1Qbv::getPortSpeed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the Port speed and get the value.</p>
<p>For calculating the duration of the guard band the port speed is required. The guard band is as long as the transmission of an Ethernet frame. The Transmission is calculated by packetSize (in bit) divided by port speed.</p>
<dl class="section return"><dt>Returns</dt><dd>the port speed </dd></dl>

</div>
</div>
<a id="a30c1b70587cd0e7478d5b2270e58c054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c1b70587cd0e7478d5b2270e58c054">&#9670;&nbsp;</a></span>getSegmentDurationFromCurrentState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t ArbiterIEEE802_1Qbv::getSegmentDurationFromCurrentState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the duration time of the segment from the current state</p>
<p>To schedule the segmentTriggerTimerMessage the duration of the current state is required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>integer value of the state from which the duration time is required </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the time of the state (time segment) </dd></dl>

</div>
</div>
<a id="a2ab97fa6f701ff5e11559c572c7f47f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab97fa6f701ff5e11559c572c7f47f5">&#9670;&nbsp;</a></span>getTimeOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t ArbiterIEEE802_1Qbv::getTimeOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the time offset.</p>
<p>If the time offset is not set, the arbitration always starts in the critical sending segment. To start in another segment the offset is used. This can be set larger than the period but does not change the timing of the arbitration. Arbitration always starts at time 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the time offset </dd></dl>

</div>
</div>
<a id="af843e309dee7139c6b9a03426ab5e713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af843e309dee7139c6b9a03426ab5e713">&#9670;&nbsp;</a></span>handleMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArbiterIEEE802_1Qbv::handleMessage </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Handle arriving messages - internal and external messages</p>
<p>There are two types of messages to handle. Internal messages are self messages that simulates time triggers. TAS two time trigger are required. The first one is the segmentTriggerTimerMessage. It is always triggered when the duration of a time segment is up. The second one is triggerSelf. It simulates the transmission delay from an Ethernet frame. There are also two types of external messages to handle. An arriving Ethernet frame is temporarily stored until its transmission delay is up. Than it is transmit to the next module. A BufferControlMessage contains information about the fill level of the FrameBuffers() in BufferModule(). </p>

</div>
</div>
<a id="a74028059ef520ea9b5213925530cfed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74028059ef520ea9b5213925530cfed2">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArbiterIEEE802_1Qbv::initialize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize the time aware shaper (TAS).</p>
<p>For the initialization: Get the period and critical interval duration. Get the maximum payload size of critical and noncritical Ethernet frames. Calculate the guard band and sending segments. Set up the segmentTriggerTimerMessage to simulate the time states of TAS. Get the current state and the next state of TAS. </p>

</div>
</div>
<a id="a0005b756e4fcacaf2c61cd432156429b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0005b756e4fcacaf2c61cd432156429b">&#9670;&nbsp;</a></span>initializeTimerMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArbiterIEEE802_1Qbv::initializeTimerMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize the timer message segmentTriggerTimerMessage to control the Arbitration.</p>
<p>To change the state under correct timing conditions a self message segmentTriggerTimerMessage is initialized. It is always sent, if the duration of a segment is finished. </p>

</div>
</div>
<a id="abc97d96003ce0ff038736d0cd5dbbff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc97d96003ce0ff038736d0cd5dbbff8">&#9670;&nbsp;</a></span>prepareBufferStatusList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structethernetHeaderInformation.html">ethernetHeaderInformation</a> * &gt; ArbiterIEEE802_1Qbv::prepareBufferStatusList </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structethernetHeaderInformation.html">ethernetHeaderInformation</a> * &gt;&#160;</td>
          <td class="paramname"><em>bufferStatusList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Preparation of the <a class="el" href="structethernetHeaderInformation.html">ethernetHeaderInformation</a> vector for arbitration.</p>
<p>EthernetHeaderInformation is a struct containing the priority of a <a class="el" href="classFrameBuffer.html">FrameBuffer()</a> and the payload size of the first Ethernet frame in a <a class="el" href="classFrameBuffer.html">FrameBuffer()</a>. If no Ethernet frame is stored in a <a class="el" href="classFrameBuffer.html">FrameBuffer()</a> it is indicated with a payload size 0. If an Ethernet frame is in the buffer (payload size &gt; 0), the boolean variable is ready from EthernetHeaderInformation is set true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferStatusList</td><td>a vector containing pointer <a class="el" href="structethernetHeaderInformation.html">ethernetHeaderInformation</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing pointer <a class="el" href="structethernetHeaderInformation.html">ethernetHeaderInformation</a> with set boolean variable ready </dd></dl>

</div>
</div>
<a id="a39184bda71a0956c6a2c980feff27a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39184bda71a0956c6a2c980feff27a89">&#9670;&nbsp;</a></span>printInitializationConfiguration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArbiterIEEE802_1Qbv::printInitializationConfiguration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print all initialization configuartions.</p>
<p>Print the period duration, the critical interval duaration, non critical interval duration, the critical sending and guard band segment duration as well as the noncritical sending and guard band segment duration. It is also the initial state and the current state printed. </p>

</div>
</div>
<a id="a2cf556524f33a915f36dce5cd51fdab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf556524f33a915f36dce5cd51fdab0">&#9670;&nbsp;</a></span>sendBufferAuthorizedBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArbiterIEEE802_1Qbv::sendBufferAuthorizedBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>authorizedBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send a authorization BufferControlMessage to <a class="el" href="classBuffersModule.html">BuffersModule</a>.</p>
<p>By arbitration the priority of the <a class="el" href="classFrameBuffer.html">FrameBuffer</a> is selected that transmit its Ethernet frame. This is told to the <a class="el" href="classBuffersModule.html">BuffersModule()</a> via BufferControlMessage with the flag SEND_AUTHORISATION.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">authorizedBuffer</td><td>integer value of the FrameBuffers priority </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a441e43984db6ac585a6673802d078877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441e43984db6ac585a6673802d078877">&#9670;&nbsp;</a></span>sendBufferRequest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArbiterIEEE802_1Qbv::sendBufferRequest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send a request to the buffer to get information about stored Ethernet frames in buffer.</p>
<p>After finishing the transmission of the waiting Ethernet frame a new Ethernet frame can start its transmission. To get the information about stored Ethernet frames in the buffer a BufferControlMessage with the flag BUFFER_CONTROL_REQUEST is transmit to the <a class="el" href="classBuffersModule.html">BuffersModule()</a>. </p>

</div>
</div>
<a id="a3eaa901b870f020a51da4db8a34d42a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eaa901b870f020a51da4db8a34d42a4">&#9670;&nbsp;</a></span>sendFrameOut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArbiterIEEE802_1Qbv::sendFrameOut </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transmit the Ethernet frames that waits for its transmission</p>
<p>A triggerSelf message is arrived. It indicates that the transmission time of the Ethernet frame is finished. Now the frame is sent. </p>

</div>
</div>
<a id="abb75f9e4fdaee5c515b1f4ea7ab78d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb75f9e4fdaee5c515b1f4ea7ab78d27">&#9670;&nbsp;</a></span>setEthPacketSizeFromPayload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ArbiterIEEE802_1Qbv::setEthPacketSizeFromPayload </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>payload</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the packet size of an Ethernet frame.</p>
<p>From the payload the packet size of an Ethernet frame is set. The frame overhead (22 byte), packet overhead (8 byte) and interpacket gap (12 byte) are added to the payload. It is required for calculating the transmission duration of an Ethernet frame.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet size of an Ethernet frame in byte depending on the payload </dd></dl>

</div>
</div>
<a id="a868a2fc6b4d6bec78f72cd7c8ad7104e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868a2fc6b4d6bec78f72cd7c8ad7104e">&#9670;&nbsp;</a></span>setTriggerDelayEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArbiterIEEE802_1Qbv::setTriggerDelayEnd </td>
          <td>(</td>
          <td class="paramtype">simtime_t&#160;</td>
          <td class="paramname"><em>transmissionPathDelay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set up timer message TriggerSelf</p>
<p>To simulate the transmission time of the Ethernet frame an self message TriggerSelf is set up. It is scheduledAt the above calculated transmission time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transmissionPathDelay</td><td>the transmission time of the Ethernet frame from one module to the next hop </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc4c0504b4d2f0154197aea47ba789fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4c0504b4d2f0154197aea47ba789fc">&#9670;&nbsp;</a></span>setUpVectorCriticalPriorities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; ArbiterIEEE802_1Qbv::setUpVectorCriticalPriorities </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>criticalPriorities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set up a boolean vector for all supported priorities to indicate their criticality.</p>
<p>For arbitration it is essential to know which priority is critical and which is not. Therefore a boolean vector is implemented. It contains for each priority an entry. True indicates that the priority is critical and false that it is noncritical.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">criticalPriorities</td><td>integer vector containing the critical priorities </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean vector indicating which of the priorities is critical (= true) or not (= false) </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1f0d89cde180ce81a038f07f96e537d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f0d89cde180ce81a038f07f96e537d3">&#9670;&nbsp;</a></span>arbiterIsBusy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ArbiterIEEE802_1Qbv::arbiterIsBusy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>variable that indicates that the arbitration is already in progress </p>

</div>
</div>
<a id="a2c6b60356a8d1b81127061b1374ef7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6b60356a8d1b81127061b1374ef7b4">&#9670;&nbsp;</a></span>criticalGuardBandSegmentDuration</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t ArbiterIEEE802_1Qbv::criticalGuardBandSegmentDuration</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>guard band segment is as long as a critical frame needs for transmission </p>

</div>
</div>
<a id="af0409eae3ddaf78cdc00f5b07e179e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0409eae3ddaf78cdc00f5b07e179e6a">&#9670;&nbsp;</a></span>criticalIntervalDuration</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t ArbiterIEEE802_1Qbv::criticalIntervalDuration</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set by user -&gt; defines the duration of the critical interval </p>

</div>
</div>
<a id="a91e2509c155332233b82a049b67621cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e2509c155332233b82a049b67621cf">&#9670;&nbsp;</a></span>criticalPriorityClasses</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; ArbiterIEEE802_1Qbv::criticalPriorityClasses</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>integer vector which stores the critical priorities (= default ("7 6")) </p>

</div>
</div>
<a id="ab4f55123dc25f8a1523ce8828dbf1f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f55123dc25f8a1523ce8828dbf1f0d">&#9670;&nbsp;</a></span>criticalSendingSegmentDuration</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t ArbiterIEEE802_1Qbv::criticalSendingSegmentDuration</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>critical interval is split into sending and guard band segment </p>

</div>
</div>
<a id="a05156ead49eba8e59dfb38f8b76d012b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05156ead49eba8e59dfb38f8b76d012b">&#9670;&nbsp;</a></span>currentBufferStatusList</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structethernetHeaderInformation.html">ethernetHeaderInformation</a>*&gt; ArbiterIEEE802_1Qbv::currentBufferStatusList</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acc0d021f02fa25a45a27e84b970f338d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0d021f02fa25a45a27e84b970f338d">&#9670;&nbsp;</a></span>currentState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ArbiterIEEE802_1Qbv::currentState</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the state is equal the current time segment </p>

</div>
</div>
<a id="a734da0537a1d8f311e88b33e7c8e3970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734da0537a1d8f311e88b33e7c8e3970">&#9670;&nbsp;</a></span>ethernetFrameWaitForTransmission</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EthernetFrame* ArbiterIEEE802_1Qbv::ethernetFrameWaitForTransmission</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>arbiter stores only one Ethernet frame which must wait for its transmission to simulate transmission rate </p>

</div>
</div>
<a id="a27bf83ee5fd90d5a8c58a99d4d2fe8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27bf83ee5fd90d5a8c58a99d4d2fe8ed">&#9670;&nbsp;</a></span>frameStoredInBuffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ArbiterIEEE802_1Qbv::frameStoredInBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae93297232e214169cb007dd3a0196526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93297232e214169cb007dd3a0196526">&#9670;&nbsp;</a></span>isCritical</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;bool&gt; ArbiterIEEE802_1Qbv::isCritical</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>boolean vector indicating which of the priorities is critical (= true) or not (= false) </p>

</div>
</div>
<a id="a51910380e66888746f37c9e603fbab26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51910380e66888746f37c9e603fbab26">&#9670;&nbsp;</a></span>maximumCriticalPayloadSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ArbiterIEEE802_1Qbv::maximumCriticalPayloadSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set by user -&gt; defines the maximum payload number in bytes for critical priorities frames </p>

</div>
</div>
<a id="ab6fd755ede90a7bfefba9ac1bcc1c8a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fd755ede90a7bfefba9ac1bcc1c8a6">&#9670;&nbsp;</a></span>maximumNoncriticalPayloadSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ArbiterIEEE802_1Qbv::maximumNoncriticalPayloadSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set by user -&gt; defines the maximum payload number in bytes for noncritical priorities frames </p>

</div>
</div>
<a id="af8156b00418775f16c22bac5018e2a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8156b00418775f16c22bac5018e2a0c">&#9670;&nbsp;</a></span>nextState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ArbiterIEEE802_1Qbv::nextState</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the next state is equal to the next time segment after the current </p>

</div>
</div>
<a id="aa65fcab578e1f85ec17dc3978f15b2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65fcab578e1f85ec17dc3978f15b2c9">&#9670;&nbsp;</a></span>noncriticalGuardBandSegmentDuration</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t ArbiterIEEE802_1Qbv::noncriticalGuardBandSegmentDuration</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>non critical guard band segment is as long as a non critical frame needs for transmission </p>

</div>
</div>
<a id="a9a4b135244637d16f0a3b03faf77b71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4b135244637d16f0a3b03faf77b71d">&#9670;&nbsp;</a></span>noncriticalIntervalDuration</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t ArbiterIEEE802_1Qbv::noncriticalIntervalDuration</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>non critical interval duration is the time remaining from the subtraction of period and criticalInterval </p>

</div>
</div>
<a id="a04e1bbc231d84226038d5260ebcfb3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e1bbc231d84226038d5260ebcfb3c1">&#9670;&nbsp;</a></span>noncriticalSendingSegmentDuration</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t ArbiterIEEE802_1Qbv::noncriticalSendingSegmentDuration</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>non critical interval duration is split into sending and guard band segment </p>

</div>
</div>
<a id="a9b7f41b6ebe5d00859c1c6b467239466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7f41b6ebe5d00859c1c6b467239466">&#9670;&nbsp;</a></span>numberSupportedPriorities</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ArbiterIEEE802_1Qbv::numberSupportedPriorities</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of supported priorities (= default 8 priorities) </p>

</div>
</div>
<a id="afea78a285b6df89b8f6b794cf360fec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea78a285b6df89b8f6b794cf360fec7">&#9670;&nbsp;</a></span>periodDuration</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t ArbiterIEEE802_1Qbv::periodDuration</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set by user -&gt; defines the duration of the period (= default 5 ms) </p>

</div>
</div>
<a id="afb6f1e5e9a74ec81759e0a7cedcaf0e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6f1e5e9a74ec81759e0a7cedcaf0e2">&#9670;&nbsp;</a></span>portIndex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ArbiterIEEE802_1Qbv::portIndex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>index of the <a class="el" href="classEgressPort.html">EgressPort</a> via which the frame is forwarded </p>

</div>
</div>
<a id="a036474f9a541a4bacce1eea6029966c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036474f9a541a4bacce1eea6029966c0">&#9670;&nbsp;</a></span>segmentTriggerTimerMessage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cMessage* ArbiterIEEE802_1Qbv::segmentTriggerTimerMessage</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cMessage timer for changing states (time segments) </p>

</div>
</div>
<a id="a05927b157ee3b7b97f9d6f51105f999c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05927b157ee3b7b97f9d6f51105f999c">&#9670;&nbsp;</a></span>switchMAC</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ArbiterIEEE802_1Qbv::switchMAC</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>MAC address of the switch. </p>

</div>
</div>
<a id="a338efe0ed92e04b82722e0690e08d87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a338efe0ed92e04b82722e0690e08d87e">&#9670;&nbsp;</a></span>timeOffset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t ArbiterIEEE802_1Qbv::timeOffset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>timer, which allows to start the simulation in any time segment (= default 0 -&gt; critical timing segment) </p>

</div>
</div>
<a id="ac8db4be8fded860e673036b509e46815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8db4be8fded860e673036b509e46815">&#9670;&nbsp;</a></span>triggerSelf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cMessage* ArbiterIEEE802_1Qbv::triggerSelf = new cMessage()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cMessage timer for trigger Ethernet frame transmission </p>

</div>
</div>
<a id="ae8ff6850fef2aab47c986255148fc3bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ff6850fef2aab47c986255148fc3bc">&#9670;&nbsp;</a></span>triggerTimer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t ArbiterIEEE802_1Qbv::triggerTimer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>timer to trigger a a self message </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classArbiterIEEE802__1Qbv.html">ArbiterIEEE802_1Qbv</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.19 </li>
  </ul>
</div>
</body>
</html>
